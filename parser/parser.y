%{
// Copyright 2013 The ql Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSES/QL-LICENSE file.

// Copyright 2022 zGraph Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Initial yacc source generated by ebnf2y[1]
// at 2013-10-04 23:10:47.861401015 +0200 CEST
//
//  $ ebnf2y -o ql.y -oe ql.ebnf -start StatementList -pkg ql -p _
//
//   [1]: http://github.com/cznic/ebnf2y

// The parser implements the PGQL specification
//
// - https://pgql-lang.org/spec/1.5/
//

package parser

import (
	"strings"

	"github.com/vescale/zgraph/parser/ast"
)

%}

%union {
	offset int // offset
	item interface{}
	ident string
	expr ast.ExprNode
	statement ast.StmtNode
}

%token	<ident>

	/*yy:token "%c"     */
	identifier "identifier"
	asof       "AS OF"

	/*yy:token "_%c"    */
	underscoreCS "UNDERSCORE_CHARSET"

	/*yy:token "\"%c\"" */
	stringLit          "string literal"
	singleAtIdentifier "identifier with single leading at"
	doubleAtIdentifier "identifier with double leading at"
	invalid            "a special token never used by parser, used by lexer to indicate error"

%token	<item>

	/*yy:token "1.%d"   */
	floatLit "floating-point literal"

	/*yy:token "1.%d"   */
	decLit "decimal literal"

	/*yy:token "%d"     */
	intLit "integer literal"

	/*yy:token "%x"     */
	hexLit "hexadecimal literal"

	/*yy:token "%b"     */
	bitLit       "bit literal"
	andnot       "&^"
	assignmentEq ":="
	eq           "="
	ge           ">="
	le           "<="
	jss          "->"
	juss         "->>"
	lsh          "<<"
	neq          "!="
	neqSynonym   "<>"
	nulleq       "<=>"
	paramMarker  "?"
	rsh          ">>"

%token not2
%type	<expr>
	Expression                 "expression"

%type	<statement>
	EmptyStmt                  "Empty statement"
	BeginStmt                  "BEGIN statement"
	CommitStmt                 "BEGIN statement"
	CreateDatabaseStmt         "Create graph databases ddl statement"
	CreateTableStmt            "Create vertex/edge tables ddl statement"
	DeleteStmt                 "Delete vertices/edges statement"
	DropDatabaseStmt           "Drop graph database ddl statement"
	DropTableStmt              "Drop vertices/edges ddl statement"
	ExplainStmt                "EXPLAIN statement"
	InsertStmt                 "Insert vertices/edges statement"
	RollbackStmt               "ROLLBACK statement"
	SelectStmt                 "Select statement"
	UpdateStmt                 "Update vertices/edges statement"
	UseStmt                    "USE statement"

%type	<ident>
	Identifier                 "identifier or unreserved keyword"

%precedence empty
%precedence lowerThanRemove

%start	Entry

%%

Entry:
	StatementList

StatementList:
	Statement
	{
		$$ = $1
	}
|	StatementList ';' Statement
	{}

Statement:
	EmptyStmt
|	BeginStmt
|	CommitStmt
|	CreateDatabaseStmt
|	CreateTableStmt
|	DeleteStmt
|	DropDatabaseStmt
|	DropTableStmt
|	ExplainStmt
|	InsertStmt
|	RollbackStmt
|	SelectStmt
|	UpdateStmt
|	UseStmt

EmptyStmt:
	/* EMPTY */
	{}

BeginStmt:
	"BEGIN"
	{}

CommitStmt:
	"COMMIT"
	{}

CreateDatabaseStmt:
	"CREATE" "DATABASE" IfNotExists DatabaseName
	{}

CreateTableStmt:
	"CREATE" TableType IfNotExists TableName TableElementListOpt
	{}

TableType:
	"VERTEX"
	{}
|	"EDGE"
	{}

TableElementListOpt:
	/* empty */
	{}
|	'(' TableElementList ')'
	{}

TableElementList:
	TableElement
	{}
|	TableElementList ',' TableElement
	{}

TableElement:
	ColumnDef
|	Constraint

ColumnDef:
	ColumnName Type ColumnOptionListOpt
	{}

ColumnOptionListOpt:
	{}
|	ColumnOptionList

ColumnOptionList:
	ColumnOption
	{}
|	ColumnOptionList ColumnOption
	{}

ColumnOption:
	"NOT" "NULL"
	{}
|	"NULL"
	{}
|	"AUTO_INCREMENT"
	{}
|	"PRIMARY" "KEY"
	{}
|	"UNIQUE" %prec lowerThanKey
	{}
|	"UNIQUE" "KEY"
	{}
|	"SOURCE" "KEY"
	{}
|	"DESTINATION" "KEY"
	{}
|	"DEFAULT" DefaultValueExpr
	{}
|	"COMMENT" stringLit
	{}
|	"REFERENCES" TableName '(' ColumnName ')'
	{}

DefaultValueExpr:
	SignedLiteral
|	NowSymOptionFractionParentheses

SignedLiteral:
	Literal
	{}
|	'+' NumLiteral
	{}
|	'-' NumLiteral
	{ÃŸ}

Literal:
	"FALSE"
	{}
|	"NULL"
	{}
|	"TRUE"
	{}
|	floatLit
	{}
|	decLit
	{}
|	intLit
	{}
|	StringLiteral %prec lowerThanStringLitToken
	{}
|	hexLit
	{}
|	bitLit
	{}

StringLiteral:
	stringLit
	{}
|	StringLiteral stringLit
	{}

NumLiteral:
	intLit
|	floatLit
|	decLit


NowSymOptionFractionParentheses:
	'(' NowSymOptionFractionParentheses ')'
	{}
|	NowSymOptionFraction

NowSymOptionFraction:
	NowSym
	{}
|	NowSymFunc '(' ')'
	{}
|	NowSymFunc '(' NUM ')'
	{}

NowSymFunc:
	"CURRENT_TIMESTAMP"
|	"LOCALTIME"
|	"LOCALTIMESTAMP"

NowSym:
	"CURRENT_TIMESTAMP"
|	"LOCALTIME"
|	"LOCALTIMESTAMP"

Constraint:
	"PRIMARY" "KEY" IndexName '(' ColumnList ')' IndexOptionList
	{}
|	KeyOrIndex IfNotExists IndexName '(' ColumnList ')' IndexOptionList
	{}
|	"UNIQUE" KeyOrIndexOpt IndexName '(' ColumnList ')' IndexOptionList
	{}

ColumnList:
	Identifier
	{}
|	ColumnList ',' Identifier
	{}

KeyOrIndex:
	"KEY"
|	"INDEX"

KeyOrIndexOpt:
	{}
|	KeyOrIndex

IndexOptionList:
	{
		$$ = nil
	}
|
	IndexInvisible
	{}
|	"COMMENT" stringLit
	{}

/*************************************Type Begin***************************************/
Type:
	NumericType
|	StringType
|	DateAndTimeType

NumericType:
	IntegerType OptFieldLen FieldOpts
	{}
|	BooleanType FieldOpts
	{}
|	FixedPointType FloatOpt FieldOpts
	{}
|	FloatingPointType FloatOpt FieldOpts
	{}
|	BitValueType OptFieldLen
	{}

IntegerType:
	"TINYINT"
	{}
|	"SMALLINT"
	{}
|	"MEDIUMINT"
	{}
|	"INT"
	{}
|	"INT1"
	{}
|	"INT2"
	{}
|	"INT3"
	{}
|	"INT4"
	{}
|	"INT8"
	{}
|	"INTEGER"
	{}
|	"BIGINT"
	{}

BooleanType:
	"BOOL"
	{}
|	"BOOLEAN"
	{}

OptInteger:
	{}
|	"INTEGER"
|	"INT"

FixedPointType:
	"DECIMAL"
	{}
|	"NUMERIC"
	{}
|	"FIXED"
	{}

FloatingPointType:
	"FLOAT"
	{}
|	"REAL"
	{}
|	"DOUBLE"
	{}
|	"DOUBLE" "PRECISION"
	{}

BitValueType:
	"BIT"
	{}

StringType:
	Char FieldLen
	{}
|	Char
	{}
|	NChar FieldLen
	{}
|	NChar
	{}
|	Varchar FieldLen
	{}
|	NVarchar FieldLen
	{}

Char:
	"CHARACTER"
|	"CHAR"

NChar:
	"NCHAR"
|	"NATIONAL" "CHARACTER"
|	"NATIONAL" "CHAR"

Varchar:
	"CHARACTER" "VARYING"
|	"CHAR" "VARYING"
|	"VARCHAR"
|	"VARCHARACTER"

NVarchar:
	"NATIONAL" "VARCHAR"
|	"NATIONAL" "VARCHARACTER"
|	"NVARCHAR"
|	"NCHAR" "VARCHAR"
|	"NCHAR" "VARCHARACTER"
|	"NATIONAL" "CHARACTER" "VARYING"
|	"NATIONAL" "CHAR" "VARYING"
|	"NCHAR" "VARYING"

Year:
	"YEAR"
|	"SQL_TSI_YEAR"

TextType:
	"TINYTEXT"
	{}
|	"TEXT" OptFieldLen
	{}
|	"MEDIUMTEXT"
	{}
|	"LONGTEXT"
	{}

DateAndTimeType:
	"DATE"
	{}
|	"DATETIME" OptFieldLen
	{}
|	"TIMESTAMP" OptFieldLen
	{}
|	"TIME" OptFieldLen
	{}
|	Year OptFieldLen FieldOpts
	{}

FieldLen:
	'(' LengthNum ')'
	{}

OptFieldLen:
	{}
|	FieldLen

FieldOpt:
	"UNSIGNED"
	{}
|	"SIGNED"
	{}
|	"ZEROFILL"
	{}

FieldOpts:
	{}
|	FieldOpts FieldOpt
	{}

FloatOpt:
	{}
|	FieldLen
	{}
|	Precision

Precision:
	'(' LengthNum ',' LengthNum ')'
	{}

StringList:
	stringLit
	{}
|	StringList ',' stringLit
	{}

TextString:
	stringLit
	{}
|	hexLit
	{}
|	bitLit
	{}

TextStringList:
	TextString
	{}
|	TextStringList ',' TextString
	{}

NUM:
	intLit

StringName:
	stringLit
|	Identifier

DeleteStmt:
	"DELETE" "FROM" TableName TableAsNameOpt WhereClauseOpt OrderByClauseOpt LimitClauseOpt
	{}

TableAsNameOpt:
	%prec empty
	{
		$$ = model.CIStr{}
	}
|	TableAsName

TableAsName:
	Identifier
	{
		$$ = model.NewCIStr($1)
	}
|	"AS" Identifier
	{
		$$ = model.NewCIStr($2)
	}

DropDatabaseStmt:
	"DROP" "DATABASE" IfExists DatabaseName

DropTableStmt:
	"DROP" "TABLE" IfExists TableName

ExplainStmt:
	"EXPLAIN" SelectStmt

InsertStmt:
	"INSERT" IntoOpt TableName InsertValues OnDuplicateKeyUpdate

IntoOpt:
	{}
|	"INTO"

InsertValues:
	'(' ColumnNameListOpt ')' ValueSym ValuesList
	{}
|	'(' ColumnNameListOpt ')' SelectStmt
	{}
|	'(' ColumnNameListOpt ')' SubSelect
	{}
|	ValueSym ValuesList %prec insertValues
	{}
|	"SET" ColumnSetValueList
	{}

ValueSym:
	"VALUE"
|	"VALUES"

ValuesList:
	RowValue
	{
		$$ = [][]ast.ExprNode{$1.([]ast.ExprNode)}
	}
|	ValuesList ',' RowValue
	{
		$$ = append($1.([][]ast.ExprNode), $3.([]ast.ExprNode))
	}

RowValue:
	'(' ValuesOpt ')'
	{
		$$ = $2
	}

ValuesOpt:
	{
		$$ = []ast.ExprNode{}
	}
|	Values

Values:
	Values ',' ExprOrDefault
	{
		$$ = append($1.([]ast.ExprNode), $3)
	}
|	ExprOrDefault
	{
		$$ = []ast.ExprNode{$1}
	}

ExprOrDefault:
	Expression
|	"DEFAULT"
	{
		$$ = &ast.DefaultExpr{}
	}

ColumnSetValue:
	ColumnName eq ExprOrDefault
	{
		$$ = &ast.Assignment{
			Column: $1.(*ast.ColumnName),
			Expr:   $3,
		}
	}

ColumnSetValueList:
	{
		$$ = []*ast.Assignment{}
	}
|	ColumnSetValue
	{
		$$ = []*ast.Assignment{$1.(*ast.Assignment)}
	}
|	ColumnSetValueList ',' ColumnSetValue
	{
		$$ = append($1.([]*ast.Assignment), $3.(*ast.Assignment))
	}

/*
 * ON DUPLICATE KEY UPDATE col_name=expr [, col_name=expr] ...
 * See https://dev.mysql.com/doc/refman/5.7/en/insert-on-duplicate.html
 */
OnDuplicateKeyUpdate:
	{
		$$ = nil
	}
|	"ON" "DUPLICATE" "KEY" "UPDATE" AssignmentList
	{
		$$ = $5
	}
/*******************************************************************************************/
Assignment:
	ColumnName eq ExprOrDefault
	{
		$$ = &ast.Assignment{Column: $1.(*ast.ColumnName), Expr: $3}
	}

AssignmentList:
	Assignment
	{
		$$ = []*ast.Assignment{$1.(*ast.Assignment)}
	}
|	AssignmentList ',' Assignment
	{
		$$ = append($1.([]*ast.Assignment), $3.(*ast.Assignment))
	}

AssignmentListOpt:
	/* EMPTY */
	{
		$$ = []*ast.Assignment{}
	}
|	AssignmentList

RollbackStmt:
	"ROLLBACK"
	{}

/*************************************Select Statement***************************************/
SubSelect:
	'(' SelectStmt ')'
	{}

SelectStmt:
	"SELECT" SelectFieldList "FROM" MatchClauseList WhereClauseOpt GroupByClauseOpt HavingClauseOpt OrderByClauseOpt LimitClauseOpt
	{}

SelectFieldList:
	FieldList
	{}

FieldList:
	Field
	{}
|	FieldList ',' Field
	{}
Field:
	'*' %prec '*'
	{}
|	Identifier '.' '*' %prec '*'
	{}
|	Identifier '.' Identifier '.' '*' %prec '*'
	{}
|	Expression FieldAsNameOpt
	{}

FieldAsNameOpt:
	/* EMPTY */
	{
		$$ = ""
	}
|	FieldAsName

FieldAsName:
	Identifier
|	"AS" Identifier
	{}
|	stringLit
|	"AS" stringLit
	{}

Expression:
	singleAtIdentifier assignmentEq Expression %prec assignmentEq
	{}
|	Expression logOr Expression %prec pipes
	{}
|	Expression "XOR" Expression %prec xor
	{}
|	Expression logAnd Expression %prec andand
	{}
|	"NOT" Expression %prec not
	{}

MatchClauseList:
	MatchClause
	{}
|	MatchClauseList ',' MatchClause
	{}

/************************MATCH CLAUSE***********************
 https://pgql-lang.org/spec/1.5/#match
 TODO:
 - SimplePathPattern
   - ReachabilityPathExpression
 - AnyPathPattern
 - AnyShortestPathPattern
 - AllShortestPathPattern
 - TopKShortestPathPattern
 - AnyCheapestPathPattern
 - TopKCheapestPathPattern
 - AllPathPattern
 ********************************************************/
MatchClause:
	"MATCH" GraphPattern OnClauseOpt RowsPerMatchOpt
	{}

GraphPathPattern:
	'(' PathPatternList ')'
	{}

PathPatternList:
	PathPattern
	{}
|	PathPatternList ',' PathPattern
	{}

PathPattern:
	SimplePathPattern
	{}

SimplePathPattern:
	VertexPattern PathPrimaryList
	{}

PathPrimaryList:
	{}
|	PathPrimaryList PathPrimary VertexPattern

PathPrimary:
	EdgePattern
	{}

EdgePattern:
	OutgoingEdgePattern
	{}
|	IncomingEdgePattern
	{}
|	AnyDirectedEdgePattern
	{}

OutgoingEdgePattern:
	'->'
|	'-[' VariableSpecification ']->'

IncomingEdgePattern:
	'<-'
|	'<-[' VariableSpecification ']-'

AnyDirectedEdgePattern:
	'-'
|	'-[' VariableSpecification ']-'

VertexPattern:
	'(' VariableSpecification ')'

VariableSpecification:
	VariableNameOpt PredicateOpt

VariableNameOpt:
	{}
|	VariableName
	{}

PredicateOpt:
	ColonOrIsKeyword LabelList

ColonOrIsKeyword:
	':'
|	"IS"

LabelList:
	Label:
	{}
|	LabelList '|' Label
	{}

Label:
	Identifier

OnClauseOpt:
	{}
|	DatabaseName
	{}

RowsPerMatchOpt:
	{}

WhereClauseOpt:
 	{}
|	"WHERE" Expression
	{}

GroupByClauseOpt:
 	{}
|	"GROUP" "BY" ByList
	{}

ByList:
	ByItem
	{}
|	ByList ',' ByItem
	{}

ByItem:
	Expression
	{}
|	Expression Order
	{}

Order:
	"ASC"
	{
		$$ = false
	}
|	"DESC"
	{
		$$ = true
	}

HavingClauseOpt:
	{
		$$ = nil
	}
|	"HAVING" Expression
	{}

OrderByClauseOpt:
 	{}
|	"ORDER" "BY" ByList
	{}

LimitClauseOpt:
 	{}
|	"LIMIT" LimitOption
	{}
|	"LIMIT" LimitOption ',' LimitOption
	{}
|	"LIMIT" LimitOption "OFFSET" LimitOption
	{}

LimitOption:
	LengthNum
	{}
|	paramMarker
	{}

LengthNum:
	NUM
	{}

UpdateStmt:
	"UPDATE" TableName TableAsNameOpt "SET" AssignmentList WhereClauseOpt OrderByClauseOpt LimitClauseOpt
	{}

UseStmt:
	"USE" DatabaseName
	{}

IfNotExists:
	{
		$$ = false
	}
|	"IF" "NOT" "EXISTS"
	{
		$$ = true
	}

DatabaseName:
	Identifier

TableName:
	{}
|	Identifier
	{}

ColumnName:
	Identifier
	{
	}
|	Identifier '.' Identifier
	{
	}
|	Identifier '.' Identifier '.' Identifier
	{
	}

IndexName:
	{}
|	Identifier
	{}

VariableName:
	Identifier

Identifier:
	identifier
%%
