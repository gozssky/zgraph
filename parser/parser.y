%{
// Copyright 2013 The ql Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSES/QL-LICENSE file.

// Copyright 2022 zGraph Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Initial yacc source generated by ebnf2y[1]
// at 2013-10-04 23:10:47.861401015 +0200 CEST
//
//  $ ebnf2y -o ql.y -oe ql.ebnf -start StatementList -pkg ql -p _
//
//   [1]: http://github.com/cznic/ebnf2y

// The parser implements the PGQL specification
//
// - https://pgql-lang.org/spec/1.5/
//

package parser

import (
	"github.com/vescale/zgraph/parser/ast"
	"github.com/vescale/zgraph/parser/model"
)

%}

%union {
	offset int // offset
	item interface{}
	ident string
	expr ast.ExprNode
	statement ast.StmtNode
}

%token	<ident>

	/*yy:token "%c"     */
	identifier "identifier"

	/*yy:token "\"%c\"" */
	stringLit          "string literal"
	singleAtIdentifier "identifier with single leading at"
	doubleAtIdentifier "identifier with double leading at"
	invalid            "a special token never used by parser, used by lexer to indicate error"
	andand             "&&"
	pipes              "||"

	/* Reserved keywords */
	as                    "AS"
	asc                   "ASC"
	bigIntType            "BIGINT"
	by                    "BY"
	create                "CREATE"
	defaultKwd            "DEFAULT"
	deleteKwd             "DELETE"
	desc                  "DESC"
	doubleType            "DOUBLE"
	drop                  "DROP"
	edge                  "EDGE"
	exists                "EXISTS"
	falseKwd              "FALSE"
	floatType             "FLOAT"
	from                  "FROM"
	group                 "GROUP"
	having                "HAVING"
	ifKwd                 "IF"
	index                 "INDEX"
	insert                "INSERT"
	integerType           "INTEGER"
	into                  "INTO"
	intType               "INT"
	is                    "IS"
	limit                 "LIMIT"
	match                 "MATCH"
	not                   "NOT"
	null                  "NULL"
	on                    "ON"
	order                 "ORDER"
	precisionType         "PRECISION"
	primary               "PRIMARY"
	selectKwd             "SELECT"
	set                   "SET"
	trueKwd               "TRUE"
	unique                "UNIQUE"
	update                "UPDATE"
	use                   "USE"
	vertex                "VERTEX"
	where                 "WHERE"
	xor                   "XOR"
	or                    "OR"
	and                   "AND"
	between               "BETWEEN"
	labels                "LABELS"
	properties            "PROPERTIES"
        caseKwd               "CASE"
        end                   "END"
        then                  "THEN"
        when                  "WHEN"
        elseKwd               "ELSE"

	/* Unreserved keywords */
	begin                 "BEGIN"
	commit                "COMMIT"
	booleanType           "BOOLEAN"
	explain               "EXPLAIN"
	yearType              "YEAR"
	dateType              "DATE"
	day                   "DAY"
	timestampType         "TIMESTAMP"
	timeType              "TIME"
	rollback              "ROLLBACK"
	offset                "OFFSET"
	graph                 "GRAPH"
	all                   "ALL"
	any                   "ANY"
	shortest              "SHORTEST"
	cheapest              "CHEAPEST"
	top                   "TOP"
	cost                  "COST"
	path                  "PATH"
	interval              "INTERVAL"
        hour                  "HOUR"
        minute                "MINUTE"
        month                 "MONTH"
        second                "SECOND"
        substring             "SUBSTRING"
        forkKwd               "FOR"
        array_agg             "ARRAY_AGG"
        avg                   "AVG"
        count                 "COUNT"
        listagg               "LISTAGG"
        max                   "MAX"
        min                   "MIN"
        sum                   "SUM"
        distinct              "DISTINCT"
        extract               "EXTRACT"
        timezone_hour         "TIMEZONE_HOUR"
        timezone_minute       "TIMEZONE_MINUTE"
        cast                  "CAST"
        long                  "LONG"
        stringKwd             "STRING"
        with                  "WITH"
        zone                  "ZONE"
        in                    "IN"
	prefix                "PREFIX"

	/* Functions */
	lower                 "LOWER"
	uppper                "UPPER"
	in_degree             "IN_DEGREE"
	java_regexp_like      "JAVA_REGEXP_LIKE"
	label                 "LABEL"
	match_number          "MATCH_NUMBER"
	out_degree            "OUT_DEGREE"
	abs                   "ABS"
	ceil                  "CEIL"
	ceiling               "CEILING"
	element_number        "ELEMENT_NUMBER"
	floor                 "FLOOR"
	has_label             "HAS_LABEL"
	id                    "ID"

%token	<item>

	/*yy:token "1.%d"   */
	decLit       "decimal literal"

	/*yy:token "%d"     */
	intLit       "integer literal"

	andnot       "&^"
	assignmentEq ":="
	eq           "="
	ge           ">="
	le           "<="
	jss          "->"
	juss         "->>"
	neq          "!="
	neqSynonym   "<>"
	nulleq       "<=>"
	paramMarker  "?"
	leftArrow    "<-"
	dashSlash    "-/"
	slashDash    "/-"
	dashBracket  "-["
	bracketDash  "]-"
	bLeftArrow   "<-["
	bRightArrow  "]->"
	sLeftArrow   "<-/"
	sRightArrow  "/->"
	allProp      ".*"

%type	<expr>
	Aggregation
	ArithmeticExpression
	BindVariable
	BracketedValueExpression
	CaseExpression
	CastSpecification
	CharacterSubstring
	ExistsPredicate
	ExtractFunction
	FunctionInvocation
	InPredicate
	IsNotNullPredicate
	IsNullPredicate
	Literal
	LogicalExpression
	NotInPredicate
	PropertyAccess
	RelationalExpression
	ScalarSubquery
	StringConcat
	StringLiteral
	SubSelect
	ValueExpression
	VariableReference

%type	<statement>
	BeginStmt
	CommitStmt
	CreateGraphStmt
	CreateIndexStmt
	DeleteStmt
	DropGraphStmt
	DropIndexStmt
	EmptyStmt
	ExplainStmt
	InsertStmt
	RollbackStmt
	SelectStmt
	Statement
	UpdateStmt
	UseStmt

%type	<ident>
	FieldAsNameOpt
	GraphName
	Identifier
	VariableName

%type   <item>
	Assignment
	ByItem
	ByList
	CostClause
	CostClauseOpt
	EdgePattern
	Field
	GraphOnClause
	GraphOnClauseOpt
	GraphPattern
	HavingClauseOpt
	IfExists
	IfNotExists
	IndexKeyTypeOpt
	IndexName
	LabelName
	LabelNameList
	LabelPredicate
	LabelPredicateOpt
	LengthNum
	LimitClauseOpt
	LimitOption
	MatchClause
	MatchClauseList
	NumericLiteral
	Order
	PathPattern
	PathPatternList
	PathPatternMacro
	PathPatternMacroList
	PatternQuantifier
	PatternQuantifierOpt
	PropertyName
	QuantifiedPathExpr
	ReachabilityPathExpr
	SelectElementList
	SimplePathPattern
	StatementList
	TableAsName
	TableAsNameOpt
	VariableLengthPathPattern
	VariableNameOpt
	VariableSpec
	VertexPattern
	VertexPatternOpt
	WhereClauseOpt

%precedence empty
%precedence insert

%right '('
%left ')'
%precedence lowerThanOn
%precedence on
%right assignmentEq
%left pipes or pipesAsOr
%left xor
%left andand and
%left between
%left eq ge le neq neqSynonym '>' '<' is in
%left '|'
%left '&'
%left '-' '+'
%left '*' '/' '%' div mod
%left '^'
%left '~' neg
%right not
%precedence ','

%start	Entry

%%

Entry:
	StatementList

StatementList:
	Statement
	{
		$$ = $1
	}
|	StatementList ';' Statement
	{}

Statement:
	EmptyStmt
|	BeginStmt
|	CommitStmt
|	CreateGraphStmt
|	CreateIndexStmt
|	DeleteStmt
|	DropGraphStmt
|	DropIndexStmt
|	ExplainStmt
|	InsertStmt
|	RollbackStmt
|	SelectStmt
|	UpdateStmt
|	UseStmt

EmptyStmt:
	/* EMPTY */
	{}

BeginStmt:
	"BEGIN"
	{}

CommitStmt:
	"COMMIT"
	{}

CreateGraphStmt:
	"CREATE" "GRAPH" IfNotExists GraphName
	{}

CreateIndexStmt:
	"CREATE" IndexKeyTypeOpt "INDEX" IfNotExists "ON" GraphName GraphName '(' PropertyNameList ')'
	{}

IndexKeyTypeOpt:
	{
		$$ = ast.IndexKeyTypeNone
	}
|	"UNIQUE"
	{
		$$ = ast.IndexKeyTypeUnique
	}

/******************************************************************************

 DELETE Statement Specification
 Reference: https://pgql-lang.org/spec/1.5/#delete

 ******************************************************************************/
DeleteStmt:
	PathPatternMacroOpt "DELETE" VariableReferenceList FromClause WhereClauseOpt GroupByClauseOpt HavingClauseOpt OrderByClauseOpt LimitClauseOpt
	{}

VariableReferenceList:
	VariableReference
	{}
|	VariableReferenceList ',' VariableReference
	{}

TableAsNameOpt:
	%prec empty
	{
		$$ = model.CIStr{}
	}
|	TableAsName

TableAsName:
	Identifier
	{
		$$ = model.NewCIStr($1)
	}
|	"AS" Identifier
	{
		$$ = model.NewCIStr($2)
	}

DropGraphStmt:
	"DROP" "GRAPH" IfExists GraphName
	{}

DropIndexStmt:
	"DROP" "INDEX" IfExists Identifier "ON" GraphName
	{}

ExplainStmt:
	"EXPLAIN" SelectStmt
	{}

/******************************************************************************

 INSERT Statement Specification
 Reference: https://pgql-lang.org/spec/1.5/#insert

 ******************************************************************************/
InsertStmt:
	"INSERT" IntoClauseOpt GraphElementInsertionList %prec insert
	{}
|	PathPatternMacroOpt "INSERT" IntoClauseOpt GraphElementInsertionList FromClause WhereClauseOpt GroupByClauseOpt HavingClauseOpt OrderByClauseOpt LimitClauseOpt
	{}

IntoClauseOpt:
	{}
|	IntoClause
	{}

IntoClause:
	"INTO" GraphName
	{}

GraphElementInsertionList:
	GraphElementInsertion
	{}
|	GraphElementInsertionList ',' GraphElementInsertion
	{}

GraphElementInsertion:
	"VERTEX" VariableNameOpt LabelsAndProperties
	{}
|	"EDGE" VariableNameOpt "BETWEEN" VertexReference "AND" VertexReference LabelsAndProperties
	{}

VertexReference:
	Identifier

LabelsAndProperties:
	LabelSpecificationOpt PropertiesSpecificationOpt

LabelSpecificationOpt:
	{}
|	LabelSpecification
	{}

LabelSpecification:
	"LABELS" '(' LabelList ')'

PropertiesSpecificationOpt:
	{}
|	PropertiesSpecification
	{}

PropertiesSpecification:
	"PROPERTIES" '(' PropertyAssignmentList ')'

PropertyAssignmentList:
	PropertyAssignment
	{}
|	PropertyAssignmentList ',' PropertyAssignment
	{}

PropertyAssignment:
	PropertyAccess '=' ValueExpression
	{}

PropertyAccess:
	VariableReference '.' PropertyName
	{}

ValueExpression:
	VariableReference
|	PropertyAccess
|	Literal
|	BindVariable
|	ArithmeticExpression
|	RelationalExpression
|	LogicalExpression
|	StringConcat
|	BracketedValueExpression
|	FunctionInvocation
|	CharacterSubstring
|	Aggregation
|	ExtractFunction
|	IsNullPredicate
|	IsNotNullPredicate
|	CastSpecification
|	CaseExpression
|	InPredicate
|	NotInPredicate
|	ExistsPredicate
|	ScalarSubquery

VariableReference:
	VariableName
	{}

Literal:
	StringLiteral
	{}
|	NumericLiteral
	{}
|	BooleanLiteral
	{}
|	DateLiteral
	{}
|	TimeLiteral
	{}
|	TimestampLiteral
	{}
|	IntervalLiteral
	{}

StringLiteral:
	stringLit
	{}

NumericLiteral:
	intLit
|	decLit

BooleanLiteral:
	"FALSE"
	{}
|	"TRUE"
	{}

DateLiteral:
	"DATE" stringLit
	{}

TimeLiteral:
	"TIME" stringLit
	{}

TimestampLiteral:
	"TIMESTAMP" stringLit
	{}

IntervalLiteral:
	"INTERVAL" stringLit DateTimeField
	{}

DateTimeField:
	"YEAR"
|	"MONTH"
|	"DAY"
|	"HOUR"
|	"MINUTE"
|	"SECOND"

BindVariable:
	'?'
	{}

ArithmeticExpression:
	'-' ValueExpression %prec neg
	{}
|	ValueExpression '*' ValueExpression %prec '*'
	{}
|	ValueExpression '/' ValueExpression %prec '/'
	{}
|	ValueExpression '%' ValueExpression %prec '%'
	{}
|	ValueExpression '+' ValueExpression %prec '+'
	{}
|	ValueExpression '-' ValueExpression %prec '-'
	{}

RelationalExpression:
	ValueExpression eq ValueExpression
	{}
|	ValueExpression neqSynonym ValueExpression
	{}
|	ValueExpression '>' ValueExpression
	{}
|	ValueExpression '<' ValueExpression
	{}
|	ValueExpression ge ValueExpression
	{}
|	ValueExpression le ValueExpression
	{}

LogicalExpression:
	ValueExpression "OR" ValueExpression %prec pipes
	{}
|	ValueExpression "XOR" ValueExpression %prec xor
	{}
|	ValueExpression "AND" ValueExpression %prec andand
	{}
|	"NOT" ValueExpression %prec not
	{}

Assignment:
	singleAtIdentifier assignmentEq ValueExpression %prec assignmentEq
	{}

StringConcat:
	ValueExpression pipes ValueExpression
	{}

BracketedValueExpression:
	'(' ValueExpression ')'
	{}

/******************************************************************************

 Reference
 - https://pgql-lang.org/spec/1.5/#user-defined-functions

 zGraph doesn't plan to support UDF and remove the PackageSpecificationOpt

 FunctionInvocation  ::= PackageSpecification? FunctionName '(' ArgumentList? ')'
 PackageSpecification::= PackageName '.'
 PackageName         ::= Identifier

 FunctionInvocation:
 	PackageSpecificationOpt FunctionName '(' ArgumentList ')'
 	{}

 PackageSpecificationOpt:
 	{}
 |	PackageName '.'
 	{}

 PackageName:
 	Identifier

 ******************************************************************************/
FunctionInvocation:
	FunctionName '(' ArgumentList ')'
	{}

FunctionName:
	"LOWER"
|	"UPPER"
|	"JAVA_REGEXP_LIKE"
|	"ABS"
|	"CEIL"
|	"CEILING"
|	"FLOOR"
|	"ID"
|	"LABEL"
|	"LABELS"
|	"HAS_LABEL"
|	"MATCH_NUMBER"
|	"ELEMENT_NUMBER"
|	"IN_DEGREE"
|	"OUT_DEGREE"

ArgumentList:
	ValueExpression
	{}
|	ArgumentList ',' ValueExpression
	{}

CharacterSubstring:
	"SUBSTRING" '(' ValueExpression "FROM" StartPosition ForStringLengthOpt ')'
	{}

StartPosition:
	ValueExpression

ForStringLengthOpt:
	{}
|	"FOR" ValueExpression
	{}

Aggregation:
	"COUNT" '(' '*' ')'
	{}
|	"COUNT" '(' DistinctOpt ValueExpression ')'
	{}
|	"MIN" '(' DistinctOpt ValueExpression ')'
	{}
|	"MAX" '(' DistinctOpt ValueExpression ')'
	{}
|	"AVG" '(' DistinctOpt ValueExpression ')'
	{}
|	"SUM" '(' DistinctOpt ValueExpression ')'
	{}
|	"ARRAY_AGG" '(' DistinctOpt ValueExpression ')'
	{}
|	"LISTAGG" '(' DistinctOpt ValueExpression ListaggSeparatorOpt')'
	{}

DistinctOpt:
	{}
|	"DISTINCT"
	{}

ListaggSeparatorOpt:
	{}
|	',' StringLiteral
	{}

ExtractFunction:
	"EXTRACT" '(' ExtractField "FROM" ValueExpression ')'
	{}

ExtractField:
	"YEAR"
	{}
|	"MONTH"
	{}
|	"DAY"
	{}
|	"HOUR"
	{}
|	"MINUTE"
	{}
|	"SECOND"
	{}
|	"TIMEZONE_HOUR"
	{}
|	"TIMEZONE_MINUTE"

IsNullPredicate:
	ValueExpression "IS" "NULL"
	{}

IsNotNullPredicate:
	ValueExpression "IS" "NOT" "NULL"
	{}

CastSpecification:
	"CAST" '(' ValueExpression "AS" DataType ')'
	{}

DataType:
	"STRING"
	{}
|	"BOOLEAN"
	{}
|	"INTEGER"
	{}
|	"INT"
	{}
|	"LONG"
	{}
|	"FLOAT"
	{}
|	"DOUBLE"
	{}
|	"DATE"
	{}
|	"TIME"
	{}
|	"TIME" "WITH" "TIME" "ZONE"
	{}
|	"TIMESTAMP"
	{}
|	"TIMESTAMP" "WITH" "TIME" "ZONE"
	{}

CaseExpression:
	SimpleCase
	{}
|	SearchedCase
	{}

SimpleCase:
	"CASE" ValueExpression WhenCaluseList ElseClauseOpt "END"

SearchedCase:
	"CASE" WhenCaluseList ElseClauseOpt "END"

WhenCaluseList:
	WhenClause
	{}
|	WhenCaluseList WhenClause
	{}

WhenClause:
	"WHEN" ValueExpression "THEN" ValueExpression
	{}

ElseClauseOpt:
	{}
|	"ELSE" ValueExpression
	{}

InPredicate:
	ValueExpression "IN" InValueList
	{}

NotInPredicate:
	ValueExpression "NOT" "IN" InValueList
	{}

InValueList:
	'(' ValueExpressionList ')'
	{}
|	BindVariable
	{}

ValueExpressionList:
	ValueExpression
	{}
|	ValueExpressionList ',' ValueExpression
	{}

ExistsPredicate:
	"EXISTS" SubSelect
	{}

ScalarSubquery:
	SubSelect
	{}

/******************************************************************************

 ROLLBACK Statement

 *****************************************************************************/
RollbackStmt:
	"ROLLBACK"
	{}

/*************************************Select Statement***************************************/
SubSelect:
	'(' SelectStmt ')'
	{}

SelectStmt:
	PathPatternMacroOpt SelectClause FromClause WhereClauseOpt GroupByClauseOpt HavingClauseOpt OrderByClauseOpt LimitClauseOpt
	{}

SelectClause:
	"SELECT" DistinctOpt SelectElementList
	{}
|	"SELECT" '*' %prec '*'
	{}

SelectElementList:
	Field
	{}
|	SelectElementList ',' Field
	{}

Field:
	ExpAsVar
	{}
|	Identifier allProp AllPropertiesPrefixOpt %prec '*'
	{}

ExpAsVar:
	ValueExpression FieldAsNameOpt
	{}

AllPropertiesPrefixOpt:
	%prec empty
	{}
|	"PREFIX" StringLiteral
	{}

FieldAsNameOpt:
	/* EMPTY */
	{
		$$ = ""
	}
|	FieldAsName
	{}

FieldAsName:
	Identifier
|	"AS" Identifier
	{}
|	stringLit
|	"AS" stringLit
	{}

FromClause:
	"FROM" MatchClauseList
	{}

MatchClauseList:
	MatchClause
	{
		$$ = &ast.MatchClauseList{Matches: []*ast.MatchClause{$1.(*ast.MatchClause)}}
	}
|	MatchClauseList ',' MatchClause
	{
		ml := $1.(*ast.MatchClauseList)
		ml.Matches = append(ml.Matches, $3.(*ast.MatchClause))
		$$ = ml
	}

MatchClause:
	"MATCH" GraphPattern GraphOnClauseOpt RowsPerMatchOpt
	{
		$$ = &ast.MatchClause{
			Graph: $3.(*ast.GraphName),
			Paths: $2.([]*ast.PathPattern),
		}
	}

GraphOnClause:
	"ON" GraphName
	{
		$$ = $2
	}

GraphOnClauseOpt:
	%prec lowerThanOn
	{
		$$ = (*ast.GraphName)(nil)
	}
|	GraphOnClause

RowsPerMatchOpt:
	{}

GraphPattern:
	PathPattern
	{
		$$ = []*ast.PathPattern{$1.(*ast.PathPattern)}
	}
|	'(' PathPatternList ')'
	{
		$$ = $2.([]*ast.PathPattern)
	}

PathPatternList:
	PathPattern
	{
		$$ = $1.(*ast.PathPattern)
	}
|	PathPatternList ',' PathPattern
	{
		$$ = append($1.([]*ast.PathPattern), $3.(*ast.PathPattern))
	}

PathPattern:
	SimplePathPattern
	{
		pp := $1.(*ast.PathPattern)
		pp.Tp = ast.PathPatternSimple
		$$ = pp
	}
|	"ANY" VariableLengthPathPattern
	{
		pp := $2.(*ast.PathPattern)
		pp.Tp = ast.PathPatternAny
		$$ = pp
	}
|	"ANY" "SHORTEST" VariableLengthPathPattern
	{
		pp := $3.(*ast.PathPattern)
		pp.Tp = ast.PathPatternAnyShortest
		$$ = pp
	}
|	"ALL" "SHORTEST" VariableLengthPathPattern
	{
		pp := $3.(*ast.PathPattern)
		pp.Tp = ast.PathPatternAllShortest
		$$ = pp
	}
|	"TOP" LengthNum "SHORTEST" VariableLengthPathPattern
	{
		pp := $4.(*ast.PathPattern)
		pp.Tp = ast.PathPatternTopKShortest
		pp.TopK = $2.(uint64)
		$$ = pp
	}
|	"ANY" "CHEAPEST" VariableLengthPathPattern
	{
		pp := $3.(*ast.PathPattern)
		pp.Tp = ast.PathPatternAnyCheapest
		$$ = pp
	}
|	"ALL" "CHEAPEST" VariableLengthPathPattern
	{
		pp := $3.(*ast.PathPattern)
		pp.Tp = ast.PathPatternAllCheapest
		$$ = pp
	}
|	"TOP" LengthNum "CHEAPEST" VariableLengthPathPattern
	{
		pp := $4.(*ast.PathPattern)
		pp.Tp = ast.PathPatternTopKCheapest
		pp.TopK = $2.(uint64)
		$$ = pp
	}
|	"ALL" VariableLengthPathPattern
	{
		pp := $2.(*ast.PathPattern)
		pp.Tp = ast.PathPatternAll
		$$ = pp
	}

SimplePathPattern:
	VertexPattern
	{
		$$ = &ast.PathPattern{Vertices: []*ast.VertexPattern{$1.(*ast.VertexPattern)}}
	}
|	SimplePathPattern ReachabilityPathExpr VertexPattern
	{
		pp := $1.(*ast.PathPattern)
		pp.Vertices = append(pp.Vertices, $3.(*ast.VertexPattern))
		pp.Connections = append(pp.Connections, $2.(*ast.ReachabilityPathExpr))
		$$ = pp
	}
|	SimplePathPattern EdgePattern VertexPattern
	{
		pp := $1.(*ast.PathPattern)
		pp.Vertices = append(pp.Vertices, $3.(*ast.VertexPattern))
		pp.Connections = append(pp.Connections, $2.(*ast.EdgePattern))
		$$ = pp
	}

VariableLengthPathPattern:
	VertexPattern QuantifiedPathExpr VertexPattern
	{
		$$ = &ast.PathPattern{
			Vertices:    []*ast.VertexPattern{$1.(*ast.VertexPattern), $3.(*ast.VertexPattern)},
			Connections: []ast.VertexPairConnection{$2.(*ast.QuantifiedPathExpr)},
		}
	}

ReachabilityPathExpr:
	"-/" LabelPredicate PatternQuantifierOpt "/->"
	{
		$$ = &ast.ReachabilityPathExpr{
			Labels:     $2.([]model.CIStr),
			Direction:  ast.EdgeDirectionOutgoing,
			Quantifier: $3.(*ast.PatternQuantifier),
		}
	}
|	"<-/" LabelPredicate PatternQuantifierOpt "/-"
	{
		$$ = &ast.ReachabilityPathExpr{
			Labels:     $2.([]model.CIStr),
			Direction:  ast.EdgeDirectionIncoming,
			Quantifier: $3.(*ast.PatternQuantifier),
		}
	}
|	"-/" LabelPredicate PatternQuantifierOpt "/-"
	{
		$$ = &ast.ReachabilityPathExpr{
			Labels:     $2.([]model.CIStr),
			Direction:  ast.EdgeDirectionAnyDirected,
			Quantifier: $3.(*ast.PatternQuantifier),
		}
	}

VertexPattern:
	'(' VariableSpec ')'
	{
		$$ = &ast.VertexPattern{Variable: $2.(*ast.VariableSpec)}
	}

VertexPatternOpt:
	{
		$$ = (*ast.VertexPattern)(nil)
	}
|	VertexPattern

EdgePattern:
	"-[" VariableSpec "]->"
	{
		$$ = &ast.EdgePattern{
			Variable:  $2.(*ast.VariableSpec),
			Direction: ast.EdgeDirectionOutgoing,
		}
	}
|	"->"
	{
		$$ = &ast.EdgePattern{Direction: ast.EdgeDirectionOutgoing}
	}
|	"<-[" VariableSpec "]-"
	{
		$$ = &ast.EdgePattern{
			Variable:  $2.(*ast.VariableSpec),
			Direction: ast.EdgeDirectionIncoming,
		}
	}
|	"<-"
	{
		$$ = &ast.EdgePattern{Direction: ast.EdgeDirectionIncoming}
	}
|	"-[" VariableSpec "]-"
	{
		$$ = &ast.EdgePattern{
			Variable:  $2.(*ast.VariableSpec),
			Direction: ast.EdgeDirectionAnyDirected,
		}
	}
|	'-'
	{
		$$ = &ast.EdgePattern{Direction: ast.EdgeDirectionAnyDirected}
	}

VariableSpec:
	VariableNameOpt LabelPredicateOpt
	{
		v := &ast.VariableSpec{
			Name:   $1.(model.CIStr),
			Labels: $2.([]model.CIStr),
		}
		if v.Name.L == "" {
			v.Anonymous = true
		}
		$$ = v
	}

VariableNameOpt:
	{
		$$ = model.CIStr{}
	}
|	Identifier
	{
		$$ = model.NewCIStr($1)
	}

LabelPredicate:
	ColonOrIsKeyword LabelNameList
	{
		$$ = $2.([]model.CIStr)
	}

LabelPredicateOpt:
	{
		$$ = []model.CIStr(nil)
	}
|	LabelPredicate

ColonOrIsKeyword:
	':'
|	"IS"

LabelList:
	Label:
	{}
|	LabelList ',' Label
	{}

Label:
	Identifier

LabelNameList:
	LabelName
	{
		$$ = []model.CIStr{$1.(model.CIStr)}
	}
|	LabelNameList '|' LabelName
	{
		$$ = append($1.([]model.CIStr), $3.(model.CIStr))
	}

QuantifiedPathExpr:
	EdgePattern PatternQuantifierOpt
	{
		$$ = &ast.QuantifiedPathExpr{
			Edge:       $1.(*ast.EdgePattern),
			Quantifier: $2.(*ast.PatternQuantifier),
		}
	}
|	'(' VertexPatternOpt EdgePattern VertexPatternOpt WhereClauseOpt CostClauseOpt ')' PatternQuantifierOpt
	{
		q := &ast.QuantifiedPathExpr{
			Edge:        $3.(*ast.EdgePattern),
			Quantifier:  $8.(*ast.PatternQuantifier),
			Source:      $2.(*ast.VertexPattern),
			Destination: $4.(*ast.VertexPattern),
		}
		if $5 != nil {
			q.Where = $5.(ast.ExprNode)
		}
		if $6 != nil {
			q.Cost = $6.(ast.ExprNode)
		}
		$$ = q
	}

CostClause:
	"COST" ValueExpression
	{
		$$ = $2.(ast.ExprNode)
	}

CostClauseOpt:
	{
		$$ = nil
	}
|	CostClause

PatternQuantifier:
	'*'
	{
		$$ = &ast.PatternQuantifier{Tp: ast.PatternQuantifierZeroOrMore, M: 18446744073709551615}
	}
|	'+'
	{
		$$ = &ast.PatternQuantifier{Tp: ast.PatternQuantifierOneOrMore, N: 1, M: 18446744073709551615}
	}
// '?' is declared as paramMarker before.
|	paramMarker
	{
		$$ = &ast.PatternQuantifier{Tp: ast.PatternQuantifierOptional, N: 0, M: 1}
	}
|	'{' LengthNum '}'
	{
		$$ = &ast.PatternQuantifier{Tp: ast.PatternQuantifierExactlyN, N: $2.(uint64), M: $2.(uint64)}
	}
|	'{' LengthNum ',' '}'
	{
		$$ = &ast.PatternQuantifier{Tp: ast.PatternQuantifierNOrMore, N: $2.(uint64), M: 18446744073709551615}
	}
|	'{' LengthNum ',' LengthNum '}'
	{
		$$ = &ast.PatternQuantifier{Tp: ast.PatternQuantifierBetweenNAndM, N: $2.(uint64), M: $4.(uint64)}
	}
|	'{' ',' LengthNum '}'
	{
		$$ = &ast.PatternQuantifier{Tp: ast.PatternQuantifierBetweenZeroAndM, N: 0, M: $3.(uint64)}
	}

PatternQuantifierOpt:
	{
		$$ = (*ast.PatternQuantifier)(nil)
	}
|	PatternQuantifier

PathPatternMacroOpt:
	%prec empty
	{}
|	PathPatternMacroList
	{}

PathPatternMacroList:
	PathPatternMacro
	{
		$$ = []*ast.PathPatternMacro{$1.(*ast.PathPatternMacro)}
	}
|	PathPatternMacroList PathPatternMacro
	{
		$$ = append($1.([]*ast.PathPatternMacro), $2.(*ast.PathPatternMacro))
	}

PathPatternMacro:
	"PATH" Identifier "AS" PathPattern WhereClauseOpt
	{
		p := &ast.PathPatternMacro{
			Name: model.NewCIStr($2),
			Path: $4.(*ast.PathPattern),
		}
		if $5 != nil {
			p.Where = $5.(ast.ExprNode)
		}
		$$ = p
	}

WhereClauseOpt:
 	{}
|	"WHERE" ValueExpression
	{}

GroupByClauseOpt:
 	{}
|	"GROUP" "BY" ByList
	{}

ByList:
	ByItem
	{}
|	ByList ',' ByItem
	{}

ByItem:
	ExpAsVar
	{}
|	ExpAsVar Order
	{}

Order:
	"ASC"
	{
		$$ = false
	}
|	"DESC"
	{
		$$ = true
	}

HavingClauseOpt:
	{
		$$ = nil
	}
|	"HAVING" ValueExpression
	{}

OrderByClauseOpt:
 	{}
|	"ORDER" "BY" ByList
	{}

LimitClauseOpt:
 	{}
|	"LIMIT" LimitOption
	{}
|	"LIMIT" LimitOption ',' LimitOption
	{}
|	"LIMIT" LimitOption "OFFSET" LimitOption
	{}

LimitOption:
	LengthNum
	{}
|	paramMarker
	{}

LengthNum:
	intLit
	{}

/******************************************************************************

 UPDATE Statement Specification
 Reference: https://pgql-lang.org/spec/1.5/#update

 ******************************************************************************/
UpdateStmt:
	PathPatternMacroOpt "UPDATE" GraphElementUpdateList FromClause  WhereClauseOpt GroupByClauseOpt HavingClauseOpt OrderByClauseOpt LimitClauseOpt
	{}

GraphElementUpdateList:
	GraphElementUpdate
	{}
|	GraphElementUpdateList ',' GraphElementUpdate
	{}

GraphElementUpdate:
	VariableReference "SET" '(' PropertyAssignmentList ')'
	{}

UseStmt:
	"USE" GraphName
	{}

IfExists:
	{
		$$ = false
	}
|	"IF" "EXISTS"
	{
		$$ = true
	}

IfNotExists:
	{
		$$ = false
	}
|	"IF" "NOT" "EXISTS"
	{
		$$ = true
	}

GraphName:
	Identifier

PropertyName:
	Identifier
	{}
|	Identifier '.' Identifier
	{}

IndexName:
	{}
|	Identifier
	{}

LabelName:
	Identifier
	{
		$$ = model.NewCIStr($1)
	}

VariableName:
	Identifier

Identifier:
	identifier

PropertyNameList:
	PropertyName
	{}
|	PropertyNameList ',' PropertyName
	{}

%%
